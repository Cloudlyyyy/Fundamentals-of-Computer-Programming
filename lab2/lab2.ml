open Num
let ni = num_of_int

(* A.1 Fibonacci again *)

(* The time complexity of the tree-recursive fibonacci function is O(2^n), but
   the space complexity is O(n). The time and space complexity is different 
   because as the size of the tree increases, the time required get exponent-
   ially larger, so it's O(2^n). However,for space complexity for a binary 
   seearch tree (ex: tree-recursive), the space complexity is the maximum nodes
   in a path from fib n to fib 0/ fib 1 meaning the path will have n nodes 
   resulting in the tree-recursive fibonacci function with a space complexity 
   of O(n) *)

(* A.2 SICP, Problem 1.1.5 *)

(* 1. When sine 12.15 is evaluated, the function p has been applied 5 times *)
(* 2. The order of growth in space and number of steps used by the process 
   generated by the sine function when sine a is evaluated is O(log(n)) for 
   number of steps because we have to divide the angle by 3 5 times which is
   exponential and by solving the equation, we get log n. The growth in space 
   is also O(log(n)) because we have to store the results before we use the
   function p *)

(* A.3 SICP, Problem 1.1.6 a *)

let rec fast_expt b n =
  let is_even m = m mod 2 = 0 in
  let square m = m * m in
    match n with 
    | 0 -> 1 
    | _ when is_even n  -> square (fast_expt b (n/2))
    | _ -> b * fast_expt b (n-1)

(* A.3 SICP, Problem 1.1.6 b *)

let ifast_expt b n = 
  let rec iter b n a = 
    let is_even m = m mod 2 = 0 in
    let square m = m * m in
      match n with 
      | 0 -> a
      | _ when is_even n  -> iter (square b) (n / 2) a
      | _ -> iter b (n-1) (a*b)
in iter b n 1

(* A.4 SICP, Problem 1.17 *)

let rec fast_mult b n  = 
  let is_even x = x mod 2 = 0 in 
  let double x = x * 2  in 
  let halve  x = x / 2 in 
    match n with 
    | 0 -> 0
    | _ when is_even n ->  double (fast_mult b (halve n))
    | _ -> b + fast_mult b (n-1)

(* A.5 SICP, Problem 1.18 *)

let ifast_mult b n = 
  let rec iter b n a = 
    let is_even x = x mod 2 = 0 in 
    let double x = x * 2  in 
    let halve  x = x / 2 in 
      match n with 
      | 0 -> a
      | _ when is_even n ->  iter (double b) (halve n) a
      | _ -> iter b (n-1) (a + b)
in iter b n 0

(* A.6 A mysterious function *)

(* The worst-case time and space complexities of the function is O(n) for time
   complexity because we are calling the function twice so when we do 2 
   (f(n /2)), the 2 would cancel out leaving with n so the time complexity will
   be n. As for space complexity, we are only keeping track of one thing at a 
   time, so it would increase from 1/2 to 1/4 to 1/8 which would give us a 
   space complexity of O(log(n)) *)

(* A.7 Fibonacci yet again *)

(* 1. This function represents a recursive process because we have to *)
(* 2. The space and time complexity of this function with respect to its 
   argument n is *)

(* B.1 Desugaring let *)

(* a. *)
(* (fun x y ->  x * (2 + y)) 20 8 *)

(* b. *)
(* (fun a b c -> sqrt (b *. b -. 4.0 *. a *. c)) 1.0 20.0 3.0 *)

(* c. *)
(* (fun x -> (fun y -> (fun z -> x * y * z) 3) 2) 1 *)

(* d. *)
(* (fun x -> (fun x -> (fun x -> x * x * x) 3) 2) 1 *)

(* 2. Desugaring let and the substitution model *)

(* desugar:

let x = 2 * 10
and y = 3 + 4
in
  let y = 14 in
  let z = 22 in
    x * y * z

to: 

(fun x y -> (fun y -> (fun z -> x * y * z )) 22) 14) 3+4) 2 * 10

eval x 
  eval 2 -> 2
  eval 10 -> 10 
  eval * -> primitive function 

eval y 
  eval 3 -> 3 
  eval 4 -> 4 
  eval + -> primitive function 

eval y 
  eval 14 -> 14 (lambda shielding so y = 14 instead of 7 )

eval z 
  eval 22 -> 22 

evalulate x * y * z 
  apply 20 14 22 to x y z 
  eval 20 -> 20 
  eval 14 -> 14 
  eval 22 -> 22 
  eval * -> primitive function 
  eval 20 * 14 * 22 
    result  = 6160 
*)

(* 3. Why doesn't this work? *) 

(* This doesn't work by desugaring the let to a fun because when we desugar 
   this expression: (fun x y z -> x + y + z) 10 x*2 y+3, x and y are not 
   defined *)

(* This can't work because the x in y = x*2 is not the same x as in x = 10, so
   we try to get the value of y, we don't know what x is, so we get an error 
   resulting in an unbounded value x since x doesn't have a value associated 
   with it *)

(* To fix this, Ben needs to change the and to in *)
(* let x = 10 in let y = x * 2 in let z = y + 3 in x + y + z *)
(* syntax error *)

(* C.1 SICP, Problem 1.30 *)

let isum term a next b =
  let rec iter a result =
    if a >/ b  
      then result
        else iter (next a) (term a +/ result)
  in
    iter a (ni 0)

(* C.2 SICP, Problem 1.31 *)

let rec product_rec term a next b = 
  if a >/ b 
    then (ni 1)
    else term a */ (product_rec term (next a) next b)


let product_iter term a next b = 
  let rec iter a result = 
    if a >/ b 
      then result
        else iter (next a) (term a */ result)
  in 
    iter a (ni 1)

let factorial_rec n = 
  let term x = x in  
  let next y = y +/ (ni 1) in 
  if n = (ni 0)
    then (ni 1)
      else product_rec term (ni 1) next n

let factorial_iter n = 
  let term x = x in  
  let next y = y +/ (ni 1) in 
  if n = (ni 0)
    then (ni 1)
      else product_iter term (ni 1) next n

let pi_product n = 
  let num_term x = x +/ (ni 2) -/ mod_num x (ni 2) in 
  let den_term x = x +/ (ni 1) +/ mod_num x (ni 2) in 
  let numerator = product_rec num_term (ni 1) (fun x -> x +/ (ni 1)) n in
  let denominator = product_rec den_term (ni 1) (fun x -> x +/ (ni 1)) n in 
  (ni 4) */ numerator // denominator 
let pi_approx = float_of_num (pi_product (ni 1000))

(* C.3 SICP, Problem 1.32 *)

let rec accumulate_rec combiner null_value term a next b = 
  if a >/ b 
    then null_value
    else combiner (term a) (accumulate_rec combiner null_value term (next a) next b)

let accumulate_iter combiner null_value term a next b = 
  let rec iter a result = 
    if a >/ b 
      then null_value
        else combiner (iter (next a) result) (term a +/ result) 
  in 
    iter a (ni 1)

(* val sum : (num -> num) -> num -> (num -> num) -> num -> num *)

let sum term a next b = 
  let combiner = ( +/ ) in 
  let null_value = (ni 0) in 
  accumulate_rec combiner null_value term a next b 

let product term a next b = 
  let combiner = ( */ ) in 
  let null_value = (ni 1) in 
  accumulate_rec combiner null_value term a next b 

(* C.4 SICP, Problem 1.42 *)

let compose f g = fun x -> f (g x)

(* C.5 SICP, Problem 1.43 *)

let rec repeated f n = 
  if n = 0 
    then fun x -> x 
      else compose f (repeated f (n-1)) 

(* C.6 SICP, Problem 1.44 *)

let smooth dx f= 
  let f_minus x = f (x-.dx) in 
  let f_x x = f x in 
  let f_add x= f (x +. dx) in 
  fun x -> (f_minus x +. f_x x +. f_add x) /. 3.0 

let nsmoothed dx f n = (repeated (smooth dx) n) f

(* D.1 is_prime *)

let is_prime n = 
  let num = int_of_float(sqrt(float_of_int n)) in 
  let rec num_rec n factor = 
    match n with 
      | _ when n < 0 -> false
      | 0 -> false 
      | 1 -> false 
      | _ when factor > num -> true 
      | _ when n mod factor = 0 -> false
      | _ -> num_rec n (factor+1) 
  in num_rec n 2
        
(* D.2 smallest_prime_factor *)

let smallest_prime_factor n = 
  let num = int_of_float(sqrt(float_of_int n)) in 
  let rec num_rec n factor = 
    match n with 
      | 0 -> invalid_arg "less than 2 "
      | 1 -> invalid_arg "less than 2"
      | _ when n mod factor = 0 -> factor
      | _ when factor > num -> invalid_arg "no prime"
      | _ -> num_rec n (factor+1) 
  in num_rec n 2


  